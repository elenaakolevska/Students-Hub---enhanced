1. Благ број е број што е составен само од парни цифри (0, 2, 4, 6, 8). Во зададен опсег (почетокот m и крајот на 
опегот n се цели броеви чија вредност се внесува од тастатура), да се најде и испечати најмалиот „благ број“.
 Ако не постои таков број, да се испечати NE.


#include <stdio.h>
int main ()
{
   int m, n;
   scanf ("%d%d", &m, &n);
   if (m%2!=0){
   m++;
} 
   for (m;m<=n;m+=2){
   int temp=m;
      while (temp){
          if (temp%2!=0){
           break;
           }
          temp/=10; }
          if (temp==0){
           printf ("%d", m);
              break;
          }
         }
    if (m>n){
     printf ("NE");}

return 0;
}

2. Eден природен e „интересен“ ако неговиот обратен број е делив со неговиот број на цифри. Обратен број е бројот составен од истите цифри,
 но во обратен редослед (на пример, 653 е обратен број на бројот 356). Од тастатура се внесува природен број n ( n > 9).
 Да се најде и отпечати најголемиот природен број помал од n кој што е „интересен“. Ако внесениот број не е валиден,
 да се отпечати соодветна порака (Brojot ne e validen).

#include <stdio.h>

int main()
{
    int n;
    scanf ("%d", &n);
    int t=n;
    for (--n; t>=9; n--){
        int temp=n;
        int brcifri=0;
        int sprotiven=0;
        while(temp){
            sprotiven=sprotiven*10 + (temp%10);
            temp/=10;
            ++brcifri;
        }
        if (sprotiven % brcifri==0){
            printf ("%d", n);
            break;
        }
    }
    if (t<=9){
        printf ("Brojot ne e validen");
    }
   
    return 0;
}


3. Од стандарден влез се чита еден природен број n. Меѓу природните броеви помали од n, да се најде оној чиј што збир 
на делителите е најголем. Во пресметувањето на збирот на делителите на даден број, да не се зема предвид самиот број.



#include <stdio.h>
int main ()
{
    int n, maxbr=1, maxsum=0;
    scanf("%d", &n);
    for (int i=2; i<n;i++){
        int sum=0;
        for (int j=1; j<i; j++){
            if (i%j==0){
                sum+=j;
            }
        }
        if (sum>maxsum){
            maxsum=sum;
            maxbr=i;
        }
    }
    printf ("%d", maxbr);
}

4. Од стандарден влез се читаат знаци се додека не се прочита извичник. Во вака внесениот текст се скриени цели броеви (помали од 100).
 Да се напише програма што ќе ги прочита сите знаци и на излез ќе го испечати збирот на сите броеви скриени во текстот.

#include <stdio.h>

int main()
{
    char znak;
    int sum=0;
    int num=0;
    
    while (scanf("%c", &znak) && znak !='!')
    {
        if (znak>='0' && znak<='9'){
            num=num*10+znak-'0';
        }
        else {
            sum+=num;
            num=0;
        }
        
    }
    printf ("%d", sum+num);
    
    return 0;
}


5. Од тастатура се читаат 2 позитивни цели броеви. Доколку се внесе барем еден негативен
број или 0 треба да се печати „Invalid input“. Треба да се определи дали помалиот 
број “е парен еквивалент” од поголемиот број. Еден број “е парен еквивалент” на друг 
број, ако и само ако неговите цифри се наоѓаат на парните позиции од другиот број, во 
истиот редослед. Соодветно да се испечатат пораки „PAREN“ и „NE“.
Позициите треба да се сметаат оддесно-налево (најмалку значајната цифра е на позиција 1)


#include <stdio.h>

int main()
{
    int a, b;
    scanf ("%d%d", &a, &b);
    if (a<=0 || b<=0){
        printf ("Invalid input");
        return 0;
    }
    if (a<b){
        int temp=a;
        a=b;
        b=temp;
    }
    a/=10;
    while (b){
       if (b%10!=a%10) {
           break;
       }
       a/=100;
       b/=10;
    }
       if (b==0){
        printf ("PAREN");
    }
    else {
        printf ("NE");
    }
     
    return 0;
}



6. Да се напише програма во која од стандарден влез прво се внесува еден позитивен цел број z,
а потоа последователно се внесуваат парови цели броеви (a, b). Внесувањето на парови цели 
броеви треба да заврши кога корисникот ќе го внесе парот (0, 0). Треба да се пресмета колку 
пати z е еднаков на збирот на секој внесен пар броеви a и b, како и колкав процент од 
вкупниот број внесени парови (a, b) даваат збир z (ЗАБЕЛЕШКА: парот (0, 0) не се зема во 
предвид при извршувањето на пресметките!).


#include <stdio.h>

int main()
{
    int brojac=0, z, a, b, brparoj=0, zbir;
    scanf ("%d", &z);
    
    while (scanf ("%d%d", &a, &b) && ((a!=0)|| (b!=0))){
         zbir=a+b;
        if (z==zbir){
            brojac++;
        }
        else {
        brparoj++;
        }
    }
    float procent= (float)brojac/(brparoj+brojac)*100.00;
    printf ("Vnesovte %d parovi od broevi chij zbir e %d\n", brojac, z);
    printf ("Procentot na parovi so zbir %d e %.2f%%", z, procent);

    return 0;
}

7. /*Со помош на знаците ‘@’,'%', и ‘.‘ се формира квадратна слика со „должина“ m (m>2) која претставува 
квадрат од знаците '.', впишан во квадрат од знаците @ и %(види примери). За внесено m да се 
испечати на екран соодветната слика. Внимавајте – не печатете нити еден дополнителен знак, како празно 
место, непотребен знак за нов ред... Сликата завршува со знак за нов ред. 
Забелешка: Бидејќи е дадено ограничување за m, во точно решение на задачата не треба да се користи низа/матрица.*/


#include <stdio.h>

int main()
{
    int m;
    scanf ("%d", &m);
    for (int i=0; i<m; i++){   // i za redovi
        for (int j=0; j<m; j++){   //j za koloni
            if (j==0 || j==m-1){
                printf ("%%");
            }
            else if (i==0 || i==m-1){
                printf ("@");
            }
            else printf (".");
        }  
     printf ("\n");
    }
    return 0;
}

8. /*Од стандарден влез се внесуваат два цели броја N и Х.
Да се најде најблискот број помал од N коj е тотално различен од бројот Х.
Еден број е тотално различен од друг ако и само ако во него не се појавува ниту една од цифрите на другиот број.
Задачата да се реши без употреба на низи и матрици.*/


#include <stdio.h>

int main()
{
    int n, x;
    scanf ("%d%d", &n, &x);
    for (--n;n>0;n--){
        int tempn=n;
        int flag=0;
        while (tempn){
            int tempx=x;
            while (tempx){
                if (tempx%10==tempn%10){
                    flag=1;
                    break;
                }
                tempx/=10;
            }
            if (flag){
                break;
            }
            tempn/=10;
        }
        if (!flag){
            break;
        }
    }
    printf ("%d", n);
    return 0;
}

9. /*Од стандарден влез се читаат непознат број на хексадецимални цифри се додека
не се внесе точка (.). Ваша задача е да го пресметате декадниот збир на внесените 
хексадецимални цифри. Доколку добиениот декаден збир е делив со 16 се печати Pogodok. Доколку истиот тој збир покрај што е делив со 16 плус завршува
на 16 (последните цифри му се 1 и 6), се печати Poln pogodok инаку се печати самиот збир.*/


#include <stdio.h>

int main()
{
   char ch;
   int sum=0;
   while (scanf ("%c", &ch) && ch!='.'){
       if (ch>='0' && ch<='9'){
           sum+=ch-'0';
       }
       else if (ch>='a' && ch<='f'){
           sum+=ch-'a' + 10;   //a=10 b=11..
       }
       else if (ch>='A' && ch<='F'){
           sum+=ch-'A' + 10;
       }
   }
   if (sum%16==0 && sum%100==16){
       printf ("Poln pogodok");
   }
   else if (sum%16==0){
       printf ("Pogodok");
   }
   else printf ("%d", sum);
    return 0;
}

ПИКСЕЛИ 

Од тастатура се вчитува природен број N, а потоа се вчитуваат последователно информации за N пиксели.
За секој пиксел се внесуваат три цели броеви коишто ги претставуваат r, g и b вредностите за соодветниот пиксел.
Пикселот е валиден ако секоја од внесените r, g и b вредности е во опсег [0, 255].
Пикселите коишто не се валидни не се земаат во предвид.Да се имплементира max rgb филтер, којшто за секој валиден 
пиксел го наоѓа максимумот од вредностите r, g и b и секоја вредност на компонентите на истиот пиксел што е 
помала од максимумот ја заменува со нула.За секој валиден пиксел се печатат новите вредности 
по извршената трансформација. 5

#include <stdio.h>
int main (){
    int n,r,g,b,maxr=0,maxb=0,maxg=0;
    scanf ("%d",&n);
    for(int i=1; i<=n;i++){
        scanf("%d %d %d",&r,&g,&b);
        if (((r<0)||(r>255))||((g<0)||(g>255))||((b<0)||(b>255))){
            continue;
        }
        if ((r>=g)&&(r>=b)){
            maxr=r;
            g=0;
            b=0;
         //   printf ("%d %d %d",maxr,g,b);

        }
        else if ((g>=r)&&(g>=b)){
            maxg=g;
            r=0;
            b=0;
           //printf ("%d %d %d",maxg,r,b);
        }
        else {
            maxb=b;
            r=0;
            g=0;
            //printf ("%d %d %d",maxb,r,g);
        }

}
      printf("%d %d %d\n",maxr,maxg,maxb);
     //printf("%d %d %d\n",r,g,b);
    return 0;
}



/*Да се напише програма во која од тастатура се внесуваат почеток и крај на интервал на цели броеви.
Програмата треба да ги испечати сите броеви од интервалот за кои ќе важи следното: превртениот еквивалент
на бројот да биде прост број. На крај да се испечати колку такви броеви постојат.
Пример:
71 – превртен еквивалент => 17 – прост број
23 – превртен еквивалент => 32 – не е прост број // нема да го печати

Vnesi interval pocetok i kraj:10
100
10 11  13  14  16  17  20  30  31  32  34  35  37  38  50  70  71  73  74  76  79  91  92  95  97  98 100*/


#include <stdio.h>
int main (){
    int n,m,prosti=0,brojac=0,i,temp;
    scanf("%d%d", &m,&n);
    for (m;m<=n;m++){
        temp=m;
        int obraten=0; //morat ovde da e na 0
        int brojac=0; //morat ovde da e na 0
        while (temp){
            obraten=obraten*10 + temp%10;
            temp/=10;
        }
        for (int j=1;j<=obraten;j++){
                if(obraten%j==0){
                brojac++;
                }
        }
        if(brojac<=2){
            printf("%d ",m);
            prosti++;
        }
    }
    printf("\nPostojat %d",prosti);
    return 0;
}

/*Да се напише програма во која од тастатура се внесуваат почеток и крај на интервал на цели броеви.
Програмата треба да ги испечати сите палиндроми од интервалот за кои ќе важи следното: производот на
цифрите на бројот да биде прост број. На крај да се испечати колку такви броеви постојат.
Пример:
121 – палиндром => 1 * 2 * 1 = 2 – прост број
212 – палиндром => 2 * 1 * 2 = 4 – не е прост број // нема да го печати+*/

#include <stdio.h>
int main(){
    int n,m,brojacprosti=0;
    scanf ("%d %d",&m,&n);
    for (m;m<=n;m++){
        int temp=m,cifra=0,proizvod=1,obraten=0,brojac=0;
        while(temp){
            cifra=temp%10;
            if(cifra!=0){
            proizvod*=cifra;
            obraten=obraten*10+cifra;
            temp/=10;
        }
        else
            break; }
        if(proizvod !=0){
        for (int i=1;i<=proizvod;i++){
            if (proizvod%i==0){
                brojac++;
            }
        }
        if (obraten==m && brojac<=2){
            brojacprosti++;
            printf("%d\t",m);
        }
    }
    }
    printf("Postojat %d",brojacprosti);
    return 0;
}



Од стандарден влез се внесуваат број x и n. Да се провери дали бројот х се содржи во внесените n броеви
од тастатура. Секогаш х ќе биде помал од внесените n броеви после него. Броевите што го исполнуваат
условот да се испечатат на екран. Доколку нема такви да се испечати Nema.
Пример: Најпрво се внесуваат х и n (нека х=23, n=4). Потоа се внесуваат (во случајов 4) броеви од тастатура
(нека бидат 1234, 2333, 1122, 1114455). Броевите што треба да се испечатат се:
1234, 2333, затоа што во нив го содржат бројот х (во случајов 23).


#include <stdio.h>
int main(){
    int x,n,temp,broj,m;
    scanf ("%d%d",&x,&n);
    broj=1;
    temp=x;
    while (temp){
        temp=temp/10;
        broj*=10;
    }
    for(int i=1;i<=n;i++){
        scanf ("%d",&m);
        temp=m;
        while (temp){
            if (temp%broj==x){
                printf ("%d\n",m);
                break;
            }
             temp/=10;
        }
    }
    return 0;
}


/*Од стандарден влез се вчитува број N, а потоа и N цели броеви. Да се испечати
на екран најголемата разлика меѓу два последователно внесени броја.
Обрјаснување на примеротЧ
N=5, па се внесуваат 5 броја: 1,3,0,5,2. Разликите се соодветно:
3-1=2
0-3=-3
5-0=5
2-5=-3
Најголема разлика е 5.*/

#include <stdio.h>
int main (){
      int n,m,razlika=0,maxrazlika=-9999,prva;
      scanf ("%d",&n);
      scanf("%d",&prva);
      for (int i=1;i<=(n-1);i++){
        razlika=0;
        scanf ("%d",&m);
        razlika=m-prva;
        if (razlika>maxrazlika){
            maxrazlika=razlika;
        }
        prva=m;
      }
      printf ("%d", maxrazlika);
}


Од тастатура се внесуваат цели броеви се додека не се внесе нешто што не е цел број. Да се испечати на 
екран сумата на броевите во кои цифрите се подредени во опаѓачки редослед. Доколку нема такви броеви, 
да се испечати  порака НЕМА. Објаснување на примерот: Во првиот пример, нема ниту еден број во кој 
цифрите се подредени во опаѓачки редослед, па се печати НЕМА.  Во вториот пример, 4321, 
21 и 81 цифрите се подредени во опаѓчки редослед, па се печати нивна сума т.е 4423
Тест пример 1: 123 124 127. ИЗЛЕЗ:  НЕМА
Тест пример 1: 123 124 127. ИЗЛЕЗ:  НЕМА


#include <stdio.h>
int main(){
   int n, suma=0,brojac=0,temp;
   while (scanf("%d",&n)){
    int temp=n;
    int flag=1;
    while (temp/10){     //do pretposledna cifra, ako ojt do posledna ke se sporedit so 0 vo if
        if (!((temp%10)<(temp%100/10))){
            flag=0;
            break;
        }
        temp/=10;
    }
    if (flag){
    suma+=n;
        brojac++;
    }
   }
    printf ("%d\n",suma);
    if (brojac==0){
        printf ("NEMA");
    }
    return 0;
}


/*Од СВ се внесува даден број Х, а потоа се внесуваат броеви додека не се внесе знак. За секој од броевите
да се провери дали бројот на цифри е еднаков со бројот на цифри на Х и доколку условот
е исполнет да се испечатат тие броеви. ВЛЕЗ:1234 453 3745 123 6850 а ИЗЛЕЗ: 3745 6850 */

#include <stdio.h>
int main (){

     int x,n;
     scanf ("%d",&x);
     int tempx=x, brojacx=1;
     while (tempx/10){
        brojacx++;
        tempx/=10;
     }
     while (scanf("%d",&n)){
        int brojacn=1;
        int tempn=n;
           while (tempn/10){
            brojacn++;
            tempn/=10;
           }
           if (brojacx==brojacn){
            printf("%d ",n);
           }
     }
 return 0;
}



 Ќе ги измине броевите од [A,B] (B нема да е помал од A) со чекор C (почнувајќи од А) и ќе пресмета:
*збир на броеви чиј квадрат е делив до D
* просек (заокружен на две децимали) на кои што цифрата на единиците или десетките (или двете) е Е (Е нема да е 0 во никој пример)
ПРИМЕР:
А=8, B=165,C=15,D=8, Е=1
броеви што ќе се изминат(8,21,32,47,60,73,86,99,112,125,138,151,164)
Квадрати на 8,60,112,64 се деливи со 8 па збир нивен е=344
21 112 151 ја содржат Е=1 и зато просекот е 94,666 (21+112+151)/3
125 138 и 164 ја имаат Е но не на бараната позиција */



#include <stdio.h>
int main ()
{
    int a,b,c,D,e,zbire=0,zbir=0,brojac=0;
    scanf ("%d%d%d%d%d", &a,&b,&c,&D,&e);
    for (a;a<=b;a+=c){
        if ((a*a)%D==0){
            zbir=zbir+a;
        }

        if ((a%10)==e || (a/10%10)==e){

            zbire=zbire+a;
            brojac++;
        }
    }
    float prosek=((float)zbire)/brojac;
    printf ("Zbirot e: %d\nProsek: %.2f", zbir,prosek);

return 0;
}


 /*Цик-цак е број за кој што важи дека за секој пар соседни цифри,
тие се наизменично поголеми односно помали една во однос на друга.
На пример, ако бројот x е составен од цифрите a, b, c, d и е, тогаш за нив важи:
a>b, b<c, c>d, d<e или a<b, b>c, c<d, d>e
Пр. 343, 4624, 6231209
Од тастатура се читаат непознат број цели броеви поголеми од или еднакви на 10 (броевите помали од 10 се игнорираат).
Читањето завршува во моментот кога ќе се прочита знак што не е цифра. Да се испечатат сите цик-цак броеви. */
#include <stdio.h>
int main()
{
    int n;

    while(scanf("%d",&n))
    {
        if(n<10)
            continue;
        int br = n;

        int flag;
        if(br%10 > br/10%10)
            flag = 1;
        else flag = 0;

        int daliZikZak = 1;
        while(br>10)
        {
            if(flag==1&&br%10<=br/10%10)
            {
                daliZikZak = 0;
                break;
            }
            if(flag==0&&br%10>=br/10%10)
            {
                daliZikZak = 0;
                break;
            }

            flag = !flag;
            br/=10;
        }
        if(daliZikZak == 1)
        {
            printf("%d",n);
        }
    }

}



Цик-цак е број за кој важи дека за секој пар соседни цифри во бројот важи дека едната е помала од 
//5, а другата е поголема или еднаква на 5. 
//На пример, ако бројот x е составен од цифрите a, b, c и d, тогаш за нив важи:
//a<5, b>=5, c<5, d>=5 или a>=5, b<5, c>=5, d<5
//Пр.  508294, 2638, 81
//Од тастатура се читаат непознат број на цели броеви поголеми од или еднакви на 10 
//(броевите помали од 10 се игнорираат). 
//Читањето завршува во моментот кога ќе се прочита знак што не е цифра. 
//Да се испечатат сите цик-цак броеви.


#include <stdio.h>

int main(){
    int br,startBr;
    while(1){
        if(!scanf("%d",&br)) break;
        startBr=br;
        if(br<10) continue;
        int znak;
        if(br%10<5){
            znak = 1;
        }else{
            znak = 0;
        }

        while(br!=0){
            br/=10;
            if(br==0){
                printf("%d\n",startBr);
                break;
            }
            if(znak){
                if(br%10<5) break; 
            }else{
                if(br%10>=5) break; 
            }
            znak=!znak;
        }

    }


    return 0;
}



/*Од тастатура се внесуваат неопределен број на цели броеви. 
Да се напише програма која ќе ги испечати броевите чија сума на цифри е прост број.*/

#include <stdio.h>
int main(){
    int a,cifra,brojac,temp,suma;
    while(scanf("%d",&a)){
        suma=0;cifra=0;temp=a;brojac=0;
        while(temp){
            cifra=temp%10;
            suma+=cifra;
            temp/=10;
        }
        for(int i=1;i<a;i++){
            if (suma%i==0){
                brojac++;
            }
        }
        if(brojac<=2) {
            printf("%d\n",a);
        }
    }
    return 0;
}

/* Да се напише код којшто од стандарден влез ќе чита информации за една фискална сметка на следниов начин:
напрво се чита број N
потоа ќе читаат уште N парови на вредности од следниот формат: износ тип_на_данаок
пр. 5 100 А 50 B 66 A 77 B 88 V
каде што првата вредност во парот изнесува износот на некој купен артикал, додека пак втората вредност 
е карактер (A, B, V) што означува каков тип на данок на додадена вредност се пресметува за тој артикал:
А означува 18%       B означува 5%        V означува 0%
Да се испечати на стандарден излез колку ќе изнесува повратокот на ДДВ за фискалната сметка што е 
вчитана од стандарден влез. Повратокот на ДДВ се пресметува како 15% од вкупно наплатеното ДДВ.
Test Case 1
Input:
5 100 A 2000 A 300 B 5000 V 7500 A
Output:
Total tax return is: 261.45*/

#include <stdio.h>

int main()
{
    int n,br;
    char c;
    float ddvA=0,ddvB=0,ddvV=0;
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d %c", &br,&c);
        if(c=='A'){
          ddvA+=br*0.18;}
       else if (c=='B'){
          ddvB+=br*0.05;}
        else if(c=='V'){
          ddvV=0;  }
    }
    float vkupnoddv= 0.15*(ddvV+ddvB+ddvA);
    printf("Total tax return is: %.2f",vkupnoddv);
    return 0;
}



/* Од влез се внесува цел позитивен број n, така што n > 2, n е непарен. Со 
помош на ѕвездички, да се исцрта "Вертикален песочен часовник" со висина и ширина n,
како во примерот:
Test Case 1
Input:
5
Output:
*****
 * * 
  *  
 * * 
***** .*/

#include <stdio.h>
int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(i==0 || i==n-1 || j+i==n-1 || j==i){
                printf("*");
            }
            else printf(" ");
        }
        printf("\n");
    }
    return 0;
}


/* Хоризонтален песочен часовник 
Од влез се внесува цел позитивен број n, така што n > 2 и n е секогаш непарен. 
Со помош на ѕвездички, да се исцрта "Хоризонтален песочен часовник" со висина и 
ширина n, како во примерот:
Test Case 1
Input: 5
Output:
*   *
** **
* * *
** **
*   *   */

#include <stdio.h>
int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(j==0 || j==n-1 || i+j==n-1 || i==j){
                printf("*");
            }
            else printf(" ");
        }
        printf("\n");
    }
    return 0;
}


/*Од стандарден влез се чита еден број кој претставува датум во формат DDMMYYYY
(DD-ден, MM-месец, YYYY-година) кој го означува денешниот датум. Потоа се
вчитува цел број N, по кој се вчитуваат N датуми на раѓање во дадениот
формат. За секој од прочитаните N датуми на раѓање треба да се отпечати "DA"
ако на денешниот ден (вчитан на почетокот) има повеќе или точно 18 години,
а во спортивно "NE".*/

#include <stdio.h>

int main()
{
    int denesen,datum,godina,denesnadgod,denesenden,denesenmesec,mesec,den,n;
    scanf("%d",&denesen);
    denesenden=denesen/1000000;
    denesenmesec=denesen/10000%100;
    denesnadgod=denesen%10000;
    scanf("%d",&n);
    for(int i=1; i<=n; i++){
        scanf("%d",&datum);
        den=datum/1000000;
        mesec=datum/10000%100;
        godina=datum%10000;
        
        if((denesnadgod-godina)==18 && mesec<=denesenmesec){
            printf("DA");}
          else  if(mesec==denesenmesec && den<=denesenden)
          {  printf("Da");}
        
       else if ((denesnadgod-godina) >18) {printf("dA");}
        
       else if ((denesnadgod-godina) < 18) {printf("Ne");
    }
        else printf("nE");
    }

    return 0;
}

/*Од тастатура се внесува цел број m, а потоа непознат број цели броеви. Да се
испечатат должините на секвенците составени од најмалку два
последователни броја за кои истовремено важи:
• следниот број е строго поголем од претходниот и
• секој од нив има точно m цифри.
Влез:
3 45 456 567 784 67890 12 543 321 462 2 23 34 567 765 898 975
Излез:
Dolzini: 3 2 4*/

#include <stdio.h>
int main () {
  int c, prethodna;
  int flag = 1, tmp, cifri, prethodencifri;
  int n = 1, m;
  scanf("%d", &m);
  while (scanf ("%d", &c)) { //nepoznat broj celi broevi
  tmp = c;
  cifri = 0;
  while (tmp) {
  cifri++;
  tmp /= 10;
  }
  if (flag) {
  flag = 0;
  } else {
           if (c > prethodna && cifri == m && prethodencifri == m) {
             n++;
               }
             else {
             if (n >= 2 ) {
                printf("%d ", n);
                       }
             n = 1;  }
  }
    prethodna = c;
    prethodencifri = cifri;
  }
  if (n >= 2 ) {
  printf("%d", n);
  }
  return 0;
}



/*Empires & Allies е стратегиска игра во повеќе нивоа со можност за играње од
страна на повеќе играчи. Секој играч има своја територија, како и одбранбени
и напаѓачки единици. Може да влезе во битка (напад на туѓа територија или
одбрана на сопствената) со други играчи што може да заврши со победа или
пораз за што се добиваат поени. Да се напише програма во која од тастарура се
внесува бројот на играчи на играта Empires & Allies. За секој играч потоа се
внесуваат податоци за ниво (цел број), број на победи и број на порази.
Резултатот на играчот се пресметува на следниот начин:
• ако се работи за прво ниво, секоја победа носи 13 поени, а секој пораз носи -1
поен
• ако се работи за второ ниво, секоја победа носи 13 поени, а секој пораз носи
-3 поени
За секој играч треба да се испечати Dobar igrac ако неговиот број на поени е
позитивен или Los igrac во сите други случаи. Потоа треба да се најде и
испечати најдобриот резултат (најголемиот вкупен број на поени), како и
редниот број на играчот со најдобар резултат (првиот играч е со реден број
еден, вториот со реден број два итн.). Ако постојат повеќе играчи со ист
најдобар резултат, да се испечати редниот број на првиот таков играч.
Влез: Излез:
4
1 3 7 Dobar igrac
2 1 8 Los igrac
2 6 4 Dobar igrac
1 5 5 Dobar igrac
Najdobar Igrac: br. 3, 66 poeni
*/

#include <stdio.h>

int main()
{
    int n, nivo, pobeda, poraz, maxpoeni=0, redenbroj=0,poenipobeda=0,poeniporaz=0,i,poeni=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
            poeni = 0, pobeda=0, poraz=0, nivo=0;
        scanf("%d %d %d", &nivo, &pobeda, &poraz);
        if(nivo==1){
            poenipobeda=pobeda*13;
            poeniporaz=poeni*(-1);
        }
        if(nivo==2){
            poenipobeda=pobeda*13;
            poeniporaz=poraz*(-3);
        }
        poeni=poenipobeda+poeniporaz;
        if(poeni>0){
            printf("Dobar igrac\n");}
            else printf("Los igrac\n");
        
    if(poeni>maxpoeni){
        maxpoeni=poeni;
        redenbroj=i;
    }}
    printf("\nNajdobar igrac %d poeni %d", redenbroj,maxpoeni);
    return 0;
}


/*Да се пронајдат сите двојки броеви во даден интервал чиј збир е превртен број од нивниот производ .
Притоа, една двојка да се печати само еднаш. Интервалот се внесува од тастатура.
Такви парови броеви се: (2,2), (3,24), (47, 2)*/

#include <stdio.h>

int main(){

   int a,b,zbir,proizvod,pocetok,kraj,i,j,obraten;
   scanf("%d %d", &pocetok,&kraj);
    for(int i=pocetok;i<=kraj;i++){
        for(int j=pocetok;j<=kraj;j++){
            proizvod=0;
            proizvod=i*j;
            int obraten=0;
            int temp = proizvod;
            while(temp){
                obraten=obraten*10 + temp%10;
                temp/=10;
            }
            if(i+j==obraten){
                printf("%d %d\n", i,j);
            }
    }
    }

  return 0;
}



/*Да се напише програма која ќе дозволи да се внесуваат непознат број на едноцифрени
и двоцифрени броеви. Од броевите што се внесуваат од тастатура да се формира нов
број преку спојување на цифрите од десно(секој нов број се спојува со претходните
преку додавање од десно). Внесувањето на цифрите прекинува кога ќе
се внесе троцифрен број или доколку воопшто не се внесе цел број.
Пример: се внесува 1 17 23 15 110
Нов број 1172315*/



/*#include <stdio.h>
int main(){
    int n;
    for(int i;i<n;i++){
      while(scanf("%d",&n)&& n>0 && n<100){
        printf("%d",n);
      }

}
}*/

#include<stdio.h>
int main(){
	int broj,prevrten;
	while(scanf("%d",&broj)){
		if(broj>99){
			break;
		}

	if((broj>=0 && broj<=9)){
	prevrten=prevrten*10+broj;//prevrten=0*10+1=1

	}
if (broj>=10 && broj<=99){
prevrten=prevrten*100+broj;//prevrten=1*100+17=117  //prevrten=117*100+23=11723  //prevrten=11723*100+15=1172315
}

}
	printf("%d",prevrten);//1172315
}
